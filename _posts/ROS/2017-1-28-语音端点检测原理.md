---
layout: post
title: "语音端点检测原理"
modified:
categories: [ROS实战,数字语音处理]
excerpt: 该博客简单介绍语音端点检测（也称活性检测）的工作原理，包括端点检测的一些常见特征判定算法，同时一步步介绍推进编程实现并测试。
tags: [Linux,ALSA,ROS,Kinect2,语音信号处理]
image: 
  feature: so-simple-sample-image-7.jpg
date: 2017-1-28T15:39:55-04:00
---


一般而言，端点检测定义为从连续音频信号中检测出实际语音片段的起始点和终止点，从而提取出有效的语音片段，排除噪声等其他非语音信号的干扰，为后续语音处理系统提供可靠的语音信号；同时，语音端点检测去除了不必要的非语音片段，减少了后续语音处理系统的计算压力，有利于提高系统的响应速度。

对于语音处理，有必要简单了解一下简单的知识点，语音可粗略分为清音和浊音两大类：

- 浊音：在时域上呈现出明显的周期性，在频域上出现共振峰且能量大部分集中在较低频段内。
- 清音：相对于很大一类噪声没有明显的时域和频域特征，类似于白噪声。　

一般情况下，语音信号是一种典型的**非平稳信号**，但是我们认为人说话是突然的，即：语音信号可假定为**短时平稳的(10-30ms)**；因此在对语音信号进行分析时，需要将语音信号以10-30ms的间隔将连续的音频信号截取成一段一段来进行分析。

---

## # 常见端点检测特征分类及处理过程

### 特征分类

**时域特征：**
- 短时能量：音信号的能量随着时间变化比较明显，一般清音部分的能量比浊音的能量小的多，所以在区分清音和浊音，有声段和无声段的应用中效果比较明显。
 - 短时过零率：表示一帧语音中语音信号波形穿过横轴（零电平）的次数。它可以用来区分清音和浊音，这是因为语音信号中的高频段有高的过零率，低频段过零率较低
- 自相关函数、基频等

**频域特征：**
- 倒谱距离、 频率方差、谱熵等

### 处理过程

1. 预处理：通常包括分帧和预滤波等。
	- 分帧是指将语音信号分段（称为语音帧，各帧通常是有交叠的）
	- 预滤波一般是指采用高通滤波器滤除低频噪声
2. 特征提取
	 - 能量、过零、频谱这些常见的特征
3. 端点判决：是指采用一种判决准则（如门限判决或模式分类等）来区分语音帧与非语音帧；
	 - 短时特征判别
	 - 模板匹配
4. 后处理：是指对上述判决结果进行间断检测，得到最终的语音端点判决结果。

---

## # 语音信号预处理原理

### 预加重

由于语音信号的平均功率谱受声门激励和口鼻辐射的影响，高频端大约在800Hz以上按6dB/倍频程跌落,即6dB/oct(2倍频)或20dB/dec(10倍频)，所以求语音信号频谱时，频率越高相应的成分越小，高频部分的频谱比低频部分的难求，为此要在预处理中进行预加重(Pre-emphasis)处理．

预加重的目的是提升高频部分，使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱，以便于频谱分析或声道参数分析．预加重可在语音信号数字化时在反混叠滤波器之前进行，这样不仅可以进行预加重，而且可以压缩信号的动态范围，有效地提高信噪比．但预加重一般是在语音信号数字化之后，在参数分析之前在计算机里用6dB/倍频程的提升高频特性的预加重数字滤波器来实现，一般：<br>

滤波器的传递函数为：

$$
H(Z) = 1-uZ^{-1}
$$

反变换后在时域上的形式为:

$$
h[n] = \xi[n] - u\xi[n-1]
$$

其中 $$\xi[n]$$ : 脉冲响应		u： 一般取接近于 1 的值

由于我们需要自己将预加重的程序实现，那么这种表达方法还不完整，接下去还需要简单推导，由以上时域表达形式，那么对于离散信号来说，只需要：<br>

**用单位样本输入的响应来表征，即用输入x[n]与单位响应h[n]作卷积**

$$
y[n]=\sum_{k=-\infty}^{\infty}x[n]h[n-k] = x[n]*h[n]
$$

式中：* 表示卷积运算操作，下面操作与上面等效

$$
y[n]=\sum_{k=-\infty}^{\infty}x[n-k]h[n] = x[n]*h[n]
$$

利用卷积的运算规则，计算出响应表达式如下：

$$
y[n]=x[n]*h[n] - ux[n-1]*h[n]= x[n] - ux[n-1]
$$


####  C++ 示例代码

```c++
/*
 * 函数功能：一阶滤波器 H(Z) = 1-uZ^{-1}
 * 离散卷积响应表示：
 * 			y[n] = x[n] - ux[n-1]
 * 参数说明：
 *	des：计算结果存放
 *	src: 原始音频采样
 *	u: 调节因子（一般接近于0）
 * */
static void preEmphasis(audio_msgs::AudioData &des,const audio_msgs::AudioData &src,float u=_u){
	for(int i=0;i<des.data_size;i++){
		if(i==0){
			des.data[i] = src.data[i];
		}else{
			des.data[i] = src.data[i] - src.data[i-1] * u;
		}
	}
}
```

---


### 分帧与加窗

对于一般的语音信号分析，这个环节必不可少。下面简单了解相关处理术语：

1. 加窗分帧：这很容易理解，即使用一个窗口将音频信号分成一段一段的，可以连续分段，但一般推荐使用交叠分段方法，这是为了使帧与帧之间平滑过度。

2. 帧移：前一帧与后一帧交叠部分，一般取　0~1/2

3. 加窗函数：对语音处理来说，短时分析的方法是有效的解决途径。就是用一个长度有限的窗序列(w(m)}截取一段语音信号来进行分析，并让这个窗滑动以便分析任一时刻附近的信号，即加窗函数。容易理解，对于一段音频信号，其中包括不同的频率的采样值，若能够对其中的每个采样点进行权重处理，就相当于滤除一部分频率的信号，这样我们需要的信号就会更加明显，方便我们分析。常见的窗函数有：矩形窗和汉明窗等
 

解析：因为声音信号在10--30ms内具有短时平稳性，选择帧长在20--30ms，例如一帧里面有160个采样点，且通道数为1，采样率为8K：那么帧长就是：160×1/8000=20ms。帧移为10ms。


#### 窗函数的定义

一般对于采样得到原始信号后，我们会将得到的信号与窗函数进行卷积运算，以便给每个采样点设置不同的权重，从而达到一定的滤波效果。具体实现形式如下：

$$
s_w(n)=s(n)*w(n)
$$

其中: <br>
$$s_w(n)$$：加窗语音信号    ;   $$w(n)$$：为窗口函数       
$$s(n)$$：原始音频信号    ;  n: 窗口长度


比较常用的窗口函数分别为：

##### 矩形窗<br>

$$w(n) =\begin{cases}
1,  & {0 \le n\le N-1} \\
0, & \text{else}
\end{cases}$$

##### 汉明窗<br>

$$w(n) =\begin{cases}
0.54-0.46cos(2*3.14*n/(N-1)),  　& {0 \le n \le N-1} \\
0, & \text{else}
\end{cases}$$

<br>
下面就汉民窗的数学定义用C++实现说明

####  C++ 示例代码
```c++
std::vector<SampleType> source;
source.reserve(size);
for (std::size_t n = 0; n < size; ++n)
{
    source.push_back(
        0.53836 - 0.46164 * std::cos(2.0 * M_PI * n / double(size - 1))
    );
}
```

简单理解就是使用一个容器来存放对应的乘积结果，当使用时就可以直接访问容器的内容就好了。

---


## # 特征提取

对于选取哪种特征来进行分析，不同的平台与不同的环境可以采取不同的策略。一般来说，对于嵌入式设备这种处理能力受到限制的平台，时域分析压力比较小。但就现在的趋势，拥有较强处理能力的嵌入式设备价格不再是太大的问题，所以将信号进行频域转换分析也是可行的。不过，能够做到在尽量少的运算得到尽量高的准确率肯定都是大家追求的。本文只对提取简单的特征作相应的分析，如能量与过零，其它比较繁琐特征的不做详细讨论。

---

**短时能量**

$$ 
E_n=\sum_{m=-\infty}^{m=+\infty} [x(m)w(n-m)]^2=\sum_{m=n-(N-1)}^{n}[x(m)w(n-m)]^2
$$

其中:<br>

$$x(m):语音信号	w(m):窗函数   N:窗长$$

根据上方定义，为编程方便，暂时使用矩形窗口来实现分帧，且帧移为零。后续如果没有达到满意的实验效果再来添加处理方法不迟。为计算方便，我们使用对数形式减少数值的大小，统一取对数如下所示:<br>

$$
E_l=logE_n=log\sum_{i=0}^{n} x_i^2
$$

---

**短时过零**

$$ Z_n=1/2\sum_{m=0}^{N-1} {|sgn[x_n(m)]-sgn[x_n(m-1)]|}$$

其中sgn(x)为符号函数：

$$ sgn(x) =
\begin{cases}
 1,  & {x \ge0} \\ 
-1, & x\lt0
\end{cases}$$

上面两个特征的定义相对简单，编程实现也比较容易。不过为了方便与统一说明，这里采用C++的信号处理库**Aquila**对函数实现进行简单说明，这里将要列举了**能量的计算**，对于**过零**也相对简单，可以自行设计

####  C++ 示例代码

```c++
double energy(const SignalSource& source)
{
	return std::accumulate(
	    std::begin(source),
	    std::end(source),
	    0.0,
	    [] (double acc, SampleType value) {
		return acc + value * value;
	    }
	);
}
``` 
这里面传递进去的是一个信号对象，其里面具体运算过程实际上是取对存放在对象里面的信号值进行运算而已。

---

一般来说，到这里已经能够进行简单语音端点检测开发工作了。接下来会具体描述如何使用ROS设计语音端点检测的节点。

---



## 参考

- [语音概念解析](http://scispeech.sourceforge.net/Chinese/Dev-pre.htm)
- [卷积运算-Wiki百科](https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF)
