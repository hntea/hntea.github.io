---
layout: post
title: "ROS下端点检测节点设计及实现"
modified:
categories: [ROS实战,数字语音处理]
excerpt: 该博客简单介绍语音信号处理中常见端点检测算法，同时一步步介绍推进编程实现并测试。
tags: [Linux,ALSA,ROS,Kinect2,语音信号处理]
image: 
  feature: so-simple-sample-image-7.jpg
date: 2017-2-5T15:39:55-04:00
---


## # ROS框架下的端点检测节点设计

在简单理解了上面的相关概念之后，接下来我们将使用 [Aquila C++ 开源信号处理库](http://aquila-dsp.org/articles/examples/) 来完成基于ROS通信框架下的**VAD**算法。

首先需要清楚的是，ROS既然是分布式通信框架，那么其目的主要是能够让每个**节点**的任务尽可能的精简。但如何精简，这需要看设计者如何设计，但此次的设计很明朗。既然要对音频信号进行分析，那么咱们可以这样划分：

- 音频捕获
- 特征提取
- VAD算法

对于音频捕获，在[上一篇博客](http://hntea.xyz/ros%E5%AE%9E%E6%88%98/ROS%E4%B8%8B%E4%BD%BF%E7%94%A8Kinect2%E8%BF%9B%E8%A1%8C%E9%9F%B3%E9%A2%91%E9%87%87%E9%9B%86/)之中已经介绍如何使用以 ALSA 挂载的音频设备获取音频数据,若还不清楚建议翻阅。

再者，每个节点虽然说有特定的任务，并且这个任务尽可能简单。但是其它节点如何与该节点保持通信呢？ROS中提供了自定义的消息类型，用起来也比较简单，详细使用已有很多教程，不过建议还是直接查看官网。由于上篇介绍了捕获，并且采用的是以块捕获的一种形式。那么这种消息数据类型该如何确定好。这里需要注意两个关键点：

- ROS消息的接收
- 每个样本的长度（决定是char or short 等）

因为要保存的音频样本长度不确定，所以尽可能选取能容纳更多位的数据类型，如float;这里所说的接收方接收整一块的数据的形式，即C++/Python接收的数据在通信过程中使用的对象分别是：

- C++：Vector 容器
- Python: 元组（好理解，保护数据不被改变）

既然这样，那么干脆就设计一个数组形式的消息就可以了,由于整一个交互系统设计在接下去开发的过程中可能会用到其它自定义消息类型，所以我们就先创建一个专门用来存放消息的包，并且在包中建立自己的消息文件，若其它功能包需要该包的消息文件，那么只需要在其它功能包的 **CMakeList.txt** 文件中添加消息包依赖即可。本次创建的消息包 audio_msgs 中建立的消息文件如下：

- AudioData.msg : 原始音频数据
- AudioFeature.msg : 单独特征
- AudioFeatures.msg : 组合特征

详细内容可以查看：[audio_msgs 消息文件设计](https://github.com/hntea/speech-system-zh/tree/master/src/audio_msgs)

消息文件已经确定，并且能够使用音频捕获节点获取信息。那么接下来就是对采集的音频信号进行特征提取。本次只采用过零和能量两种特征，其它特征先不考虑。

### 运用Aquila库提取特征

## 参考

- [语音概念解析](http://scispeech.sourceforge.net/Chinese/Dev-pre.htm)
- [卷积运算-Wiki百科](https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF)
- [Aquila C++ 开源信号处理库](http://aquila-dsp.org/articles/examples/)
- [ROS 自定义消息官方教程](http://wiki.ros.org/cn/ROS/Tutorials/DefiningCustomMessages)