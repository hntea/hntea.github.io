---
layout: post
title: "ROS下端点检测节点设计及实现"
modified:
categories: [ROS实战,数字语音处理]
excerpt: 该博客简单介绍语音信号处理中常见端点检测算法，同时一步步介绍推进编程实现并测试。
tags: [Linux,ALSA,ROS,Kinect2,语音信号处理]
image: 
  feature: so-simple-sample-image-7.jpg
date: 2017-2-5T15:39:55-04:00
---


## # ROS框架下的端点检测节点设计

在简单理解了上面的相关概念之后，接下来我们将使用 [Aquila C++ 开源信号处理库](http://aquila-dsp.org/articles/examples/) 来完成基于ROS通信框架下的**VAD**算法。

首先需要清楚的是，ROS既然是分布式通信框架，那么其目的主要是能够让每个**节点**的任务尽可能的精简。但如何精简，这需要看设计者如何设计，但此次的设计很明朗。既然要对音频信号进行分析，那么咱们可以这样划分：

- 音频捕获
- 特征提取
- VAD算法

对于音频捕获，在[上一篇博客](http://hntea.xyz/ros%E5%AE%9E%E6%88%98/ROS%E4%B8%8B%E4%BD%BF%E7%94%A8Kinect2%E8%BF%9B%E8%A1%8C%E9%9F%B3%E9%A2%91%E9%87%87%E9%9B%86/)之中已经介绍如何使用以 ALSA 挂载的音频设备获取音频数据,若还不清楚建议翻阅。

再者，每个节点虽然说有特定的任务，并且这个任务尽可能简单。但是其它节点如何与该节点保持通信呢？ROS中提供了自定义的消息类型，用起来也比较简单，详细使用已有很多教程，不过建议还是直接查看官网。由于上篇介绍了捕获，并且采用的是以块捕获的一种形式。那么这种消息数据类型该如何确定好。这里需要注意两个关键点：

- ROS消息的接收
- 每个样本的长度（决定是char or short 等）

因为要保存的音频样本长度不确定，所以尽可能选取能容纳更多位的数据类型，如float;这里所说的接收方接收整一块的数据的形式，即C++/Python接收的数据在通信过程中使用的对象分别是：

- C++：Vector 容器
- Python: 元组（好理解，保护数据不被改变）

既然这样，那么干脆就设计一个数组形式的消息就可以了,由于整一个交互系统设计在接下去开发的过程中可能会用到其它自定义消息类型，所以我们就先创建一个专门用来存放消息的包，并且在包中建立自己的消息文件，若其它功能包需要该包的消息文件，那么只需要在其它功能包的 **CMakeList.txt** 文件中添加消息包依赖即可。本次创建的消息包 audio_msgs 中建立的消息文件如下：

- AudioData.msg : 原始音频数据
- AudioFeature.msg : 单独特征
- AudioFeatureSet.msg : 组合特征

详细内容可以查看：[audio_msgs 消息文件设计](https://github.com/hntea/speech-system-zh/tree/master/src/audio_msgs)

消息文件已经确定，并且能够使用音频捕获节点获取信息。那么接下来就是对采集的音频信号进行特征提取。本次只采用过零和能量两种特征，其它特征先不考虑。

### 提取特征

在进行特征提取之前，需要明确接下去的端点判决说需要的特征。为了在端点判决时比较容易处理，这次特征提取后将不同的特征打包后再通过节点发送。如果后续还需要添加其它特征，那么依据文件来修改会比较简单。具体该如何设计好？要不就设计一个类，方便自己再次扩展。这次的类设计头文件如下：

####  特征类设计

```c++
namespace Hntea {

class FeatureSet: public Aquila::SignalSource
{
public:
	FeatureSet();
	FeatureSet(const std::vector<int16_t>& source,double frequence);
	virtual ~FeatureSet();


	/*
	 * 函数功能：均值统计
	 * 参数说明：
	 * 返回值：均值
	 * */
	float mean();

	/*
	 * 函数功能：统计过零率
	 * 参数说明：
	 * 返回值：过零率
	 * */
	float zeroCrossing();

	/*
	 * 函数功能：统计对数能量
	 * 参数说明：
	 * 返回值：对数能量
	 * */
	float logEnergy();

};
```

这个类直接继承了信号处理库中的类，这里没有什么目的，只是觉得这个信号类设计的很好，想直接拿下来用而已。具体的实现文件也比较简单。若有兴趣可以[跳转到此处查看源码.](https://github.com/hntea/speech-system-zh/blob/master/src/audio_fectures/src/feature_set/FeatureSet.cpp)

我们一直想让每个节点的任务尽可能的简单的原因是，当出现问题时，可以很容易的定位到相应的节点文件中去。那么对于特征节点采集这个节点，有了上面的实现类，下面只需要在节点文件中直接调用并配合消息文件就好了。

####  特征发布节点设计

```
/*
 * feature_set.cpp
 *
 *  Created on: 2017年2月27日
 *      Author: hntea
 *
 * 函数功能：多特征采集
 */

#include <iostream>
#include <vector>
#include "audio_msgs/AudioData.h"
#include "audio_msgs/AudioFeatureSet.h"
#include "ros/ros.h"
#include "FeatureSet.h"


ros::Publisher _pub;
float _frq;

void callback(const audio_msgs::AudioData &msgs)
{
	std::vector<int16_t> src(msgs.data);
	Hntea::FeatureSet features(src,_frq);
	audio_msgs::AudioFeatureSet features_msgs;
	features_msgs.logenergy = features.logEnergy();
	features_msgs.mean = features.mean();
	features_msgs.zerocrossing = features.zeroCrossing();
	_pub.publish(features_msgs);
}

int main (int argc, char **argv)
{
	ros::init(argc, argv, "feature_set");
	if(!ros::param::get("/audio_capture/sample_rate",_frq))
	{
		_frq = 16000;
	}
	ros::NodeHandle n;
	ros::Subscriber sb = n.subscribe("hamming_window",50,callback);
	_pub = n.advertise<audio_msgs::AudioFeatureSet>("audio_feature/feature_set",1000);
	ros::spin();
	return 0;
}

```
是不是很简单？只要把ROS的节点模板一套，然后通过我们自定义的消息文件（简单的说就是自定义的数据结构），万事大吉。下面只需要简单的编译，之后运行节点就能够正常发布消息了。接下来如何使用消息订阅来完成端点检测呢？

---

### 端点检测设计

## 参考

- [语音概念解析](http://scispeech.sourceforge.net/Chinese/Dev-pre.htm)
- [卷积运算-Wiki百科](https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF)
- [Aquila C++ 开源信号处理库](http://aquila-dsp.org/articles/examples/)
- [ROS 自定义消息官方教程](http://wiki.ros.org/cn/ROS/Tutorials/DefiningCustomMessages)